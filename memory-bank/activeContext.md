# アクティブコンテキスト

## 現在の作業フォーカス

現在のプロジェクトフェーズは、**基本実装段階**です。基本的なアプリケーション構造と主要機能のバックエンドロジック（コマンド）は存在しますが、永続化層が欠落していました。
今回、**iroh を使用したストレージレイヤーの再実装** が完了し、モック実装から本格的な実装への移行が完了しました。

### 主な焦点領域

1.  **iroh-gossipの実装の完成**: iroh-gossipの基本的な実装は進行中ですが、実際のP2P通信の検証やエラーハンドリングの改善が必要です。(変更なし)
2.  **Tauri コマンドとストレージの統合**: 新しく実装されたストレージリポジトリを Tauri コマンドハンドラから呼び出し、エラーハンドリングを適切に行う必要があります。(完了)
3.  **ドキュメント同期とイベント処理**: `iroh-docs` の `subscribe` 機能を利用してドキュメントの変更を監視し、フロントエンドにリアルタイムで反映させる仕組みを実装する必要があります。(最優先タスク)
4.  **UIの改善**: 基本的なUIは実装されていますが、ユーザーエクスペリエンスの向上のために改善が必要です。(変更なし)
5.  **テストの実装**: ユニットテスト、統合テスト、E2Eテストを実装する必要があります。特にストレージリポジトリのテストを優先的に行う必要があります。(優先度上昇)
6.  **パフォーマンスの最適化**: データ同期やP2P通信のパフォーマンスを最適化する必要があります。(変更なし)
7.  **AppSettings の実装**: (完了) アプリケーション設定を保存するためのストレージ実装が完了しました。

## 最近の変更

1.  **ストレージレイヤーの再実装 (irohベース)**:
    *   `./src-tauri/src/storage` ディレクトリをゼロから再構築。
    *   `iroh` (Endpoint), `iroh-gossip`, `iroh-blobs`, `iroh-docs` を初期化し、Tauri アプリケーションのライフサイクルで管理する仕組み (`IrohNode`, `state`) を実装。
    *   リポジトリパターンを採用し、`UserRepository` (`user_repository.rs`) と `PostRepository` (`post_repository.rs`) を実装。
        *   `User` および `Post` モデルの CRUD (Create, Read, Update, Delete) 操作とリスト取得機能を提供。
        *   固定の `NamespaceId` を使用してドキュメントを分離。
        *   `iroh-docs` の `Doc` ハンドルを取得して操作する方式に変更。
    *   データモデル用のトレイト (`HasId`, `PostEntry`) を `storage/traits.rs` に移動。
    *   関連するビルドエラー（依存関係、API 非互換、型エラー、ライフタイムエラー等）を修正。
2.  **Tauri コマンドの更新**:
    *   `auth`, `post`, `profile` コマンドが新しいストレージリポジトリ関数を呼び出すように修正。
    *   `settings` コマンドが新しい `AppSettings` リポジトリを使用するように修正。
3.  **基本的なアプリケーション構造の実装**: (変更なし)
    *   フロントエンド: React、TypeScript、Zustandを使用したUI実装
    *   バックエンド: Tauriコマンドを使用したRust実装
    *   データモデル: Zodスキーマを使用したデータモデル定義
4.  **iroh-gossipの実装進行**: (変更なし)
    *   iroh-gossipの依存関係の追加
    *   MessageType列挙型の定義
    *   IrohNetwork構造体の実装
    *   トピックベースのメッセージング機能の実装
    *   publish_post, publish_profile, publish_follow, publish_unfollowなどの関数の実装
    *   基本的なテスト構造の実装
5.  **主要機能の実装**: (変更なし、ただしストレージ依存部分は更新済み)
    *   ユーザー認証: ユーザー作成、サインイン、ユーザーリスト取得
    *   投稿管理: 投稿作成、取得、検索 (検索は未実装)
    *   プロフィール管理: プロフィール取得、更新
    *   フォロー機能: フォロー、アンフォロー
6.  **データモデルの実装**: (変更なし、トレイトパス修正済み)
    *   User, Postなどの基本的なデータモデルを実装
    *   HasId, PostEntryなどのトレイトを定義
    *   シリアライズ/デシリアライズのサポート
7.  **AppSettings リポジトリの実装**:
    *   `src-tauri/src/models/settings.rs` に `Settings` 構造体を定義。
    *   `src-tauri/src/storage/repository/settings_repository.rs` を作成し、設定の保存・取得ロジックを実装。
    *   `src-tauri/src/storage/iroh_node.rs` に `SETTINGS_NAMESPACE_ID` を定義。
    *   グローバル設定とユーザー固有設定の両方をサポート。

## 次のステップ

### 短期的なタスク（1-2週間）

1.  **ドキュメント同期とイベント処理の実装**: (最優先)
    *   `iroh-docs` の `Doc::subscribe()` を使用して、User および Post ドキュメントの変更を監視する。
    *   変更イベント (`LiveEvent`) を受け取り、関連データを取得・更新する。
    *   Tauri イベント (`app_handle.emit_all`) を使用して、フロントエンドに変更を通知する。
2.  **テスト実装の拡充**: (優先度上昇)
    *   ストレージリポジトリに対するユニットテストを追加。
    *   Tauri コマンドの統合テストを実装。
    *   P2P通信のテスト方法の確立。
3.  **iroh-gossipの実装完成**:
    *   実際のP2P通信のテストと検証
    *   エラーハンドリングの改善
    *   パフォーマンスの最適化
    *   実際のネットワーク環境でのテスト
4.  **Tauri コマンドのエラーハンドリング改善**:
    *   各コマンドハンドラでのエラーハンドリング (`map_err` など) を見直し、`StorageError` から各コマンド固有エラーへの変換を確実に行う。

### 中期的なタスク（3-5週間）

*   ユーザー認証とプロフィール管理の強化 (変更なし)
*   投稿作成と表示機能の強化 (変更なし)
*   タイムラインの最適化 (変更なし)
*   P2P通信の最適化 (変更なし)
*   フォロー/フォロワー機能の強化 (変更なし)
*   ローカル検索機能の実装 (`post_repository` に追加)

## アクティブな決定事項

1.  **技術スタックの選択**: (変更なし)
    *   フロントエンド: React、TypeScript、Vite、Zustand、TanStack Query
    *   バックエンド: Tauri、Rust、iroh-docs、iroh-gossip、iroh-blobs
    *   テスト: Vitest、Playwright、Mockall、tokio-test、test-log、env_logger
2.  **アーキテクチャの決定**: (変更なし)
    *   クライアントサイドアプリケーション
    *   分散型P2Pネットワーク
    *   ローカルファーストデータ管理
    *   モジュール型サービス統合
    *   トピックベースのメッセージング
3.  **データモデルの設計**: (変更なし)
    *   ユーザープロフィール（User）
    *   投稿（Post）
    *   フォロー関係
    *   メッセージタイプ（MessageType列挙型）
    *   ネットワークステータス（NetworkStatus）
4.  **実装アプローチ**: (変更なし)
    *   段階的な実装（MVP→拡張機能→エコシステム拡大→スケーリング）
    *   テスト駆動開発
    *   モジュール化されたコードベース
    *   エラーハンドリングの標準化（thiserrorを使用）
5.  **ストレージ技術**: (更新)
    *   `iroh-docs` を主要なデータストレージとして採用。
    *   `iroh-blobs` をコンテンツストレージとして採用。
    *   リポジトリパターンでデータアクセスを抽象化。
    *   固定の `NamespaceId` を使用して User, Post, Settings のドキュメントを分離 (現在の実装)。
    *   ユーザー固有の設定とグローバル設定の両方をサポート。

## 現在の考慮事項

1.  **パフォーマンス最適化**: (変更なし)
    *   iroh-docsのデータ構造の最適化
    *   P2P通信の効率化（特にトピックベースのメッセージング）
    *   リソース使用量の最適化（メモリ、CPU、ネットワーク帯域）
    *   大量のメッセージ処理時のパフォーマンス
2.  **セキュリティ考慮事項**: (変更なし)
    *   ユーザーデータの保護
    *   通信の暗号化（iroh-gossipの暗号化機能の活用）
    *   権限管理
    *   秘密鍵の安全な保存（現在はtempディレクトリに保存）
    *   メッセージの認証と検証
3.  **ユーザーエクスペリエンス**: (変更なし)
    *   オンボーディングプロセスの設計
    *   UIの使いやすさ
    *   オフライン対応
    *   エラーハンドリングの改善（ユーザーフレンドリーなエラーメッセージ）
    *   ネットワーク状態の表示
4.  **スケーラビリティ**: (変更なし)
    *   大規模データセットの処理
    *   多数のユーザーとの同期
    *   リソース使用量の管理
    *   効率的なデータ同期メカニズム
    *   トピック数の増加に対する対応
5.  **テスト戦略**: (優先度上昇)
    *   ユニットテスト（基本構造は実装済み）
    *   統合テスト
    *   E2Eテスト
    *   パフォーマンステスト
    *   モックの活用（mockallを使用）
    *   P2P通信のテスト方法
6.  **Namespace 管理**: (更新)
    *   現在使用している固定の Namespace ID (User, Post, Settings) は適切か？将来的にユーザーごと、または他の基準で Namespace を分割する必要はあるか？
    *   Namespace の Capability をどのように管理・共有するか？
    *   Settings Namespace はグローバル設定とユーザー固有設定の両方をサポートするように実装されている。
7.  **リポジトリの効率**: (更新)
    *   `list_user_posts` のようなフィルタリング処理は、データ量が増えると非効率になる。iroh-docs のクエリ機能やインデックス戦略を検討する必要があるか？
    *   大量のデータに対するクエリ最適化手法の検討。

## オープンな質問

1.  **iroh-docsのパフォーマンス**: (変更なし) 大規模データセットでのiroh-docsのパフォーマンスはどうか？特に多数のエントリーを持つドキュメントの同期パフォーマンスはどうか？
2.  **iroh-gossipのスケーラビリティ**: (変更なし) 多数のユーザーがいる場合のiroh-gossipのスケーラビリティはどうか？トピックベースのメッセージングの効率はどうか？実装したトピック設計は効率的か？
3.  **クロスプラットフォーム互換性**: (変更なし) 異なるプラットフォーム間での一貫したユーザーエクスペリエンスをどのように確保するか？特にTauriアプリケーションのプラットフォーム固有の挙動をどう扱うか？
4.  **オフライン対応**: (変更なし) オフライン状態でのユーザーエクスペリエンスをどのように最適化するか？特に同期の競合解決をどのように実装するか？
5.  **モデレーション**: (変更なし) 分散型システムでのコンテンツモデレーションをどのように実装するか？ユーザー主導のモデレーションメカニズムは可能か？
6.  **テスト戦略**: (変更なし) 分散型システムのテストをどのように効果的に実装するか？特にP2P通信のテストをどのように行うか？モックを使用したテストは十分か？
7.  **秘密鍵管理**: (変更なし) 現在の秘密鍵保存方法（tempディレクトリ）は本番環境に適しているか？より安全な保存方法は？
8.  **エラーハンドリング**: (変更なし) 現在のエラーハンドリング（thiserrorを使用）は十分か？ユーザーフレンドリーなエラーメッセージをどのように提供するか？
9.  **トピック設計**: (変更なし) 現在のトピック設計（global/posts, user/{id}/posts, user/{id}/profile, user/{id}/following）は効率的か？より良い設計はあるか？
10. **Namespace 管理戦略**: (更新) User, Post, Settings で固定 Namespace を使用する現在の方法は適切か？将来的な拡張性を考慮すると、どのような管理戦略が望ましいか？
11. **イベント処理アーキテクチャ**: (新規) `subscribe` を使用した変更監視とイベント発火のベストプラクティスは？イベントループのパフォーマンスと信頼性をどう確保するか？