# アクティブコンテキスト

## 🎉 重要な修正完了

**CRITICAL RUNTIME ERROR RESOLVED**: NamespaceId creation issue has been successfully fixed!

- **問題**: アプリケーションが起動時に "Invalid static USER namespace string: Odd number of digits" エラーでクラッシュ
- **原因**: `NamespaceId::from_str()` は16進文字列を期待するが、プレーンテキスト ("kukuri-user-profiles-v1") を渡していた
- **解決策**: blake3ハッシュを使用してプレーンテキスト識別子から決定論的な32バイト配列を生成し、`NamespaceId::from()` で作成
- **結果**: アプリケーションが正常に起動し、すべての機能が利用可能に

## 現在の作業フォーカス

現在のプロジェクトフェーズは、**テスト修正完了 & システム安定化**段階です。動的NamespaceId管理システムの移行完了、全コンパイルエラーの解決、アプリケーションの正常起動確認、そして統合テストの修正まで完了し、システムが安定した状態に到達しました。

### 主な焦点領域

1.  **動的NamespaceId管理システムの実装**: ✅ **完了** - 固定NamespaceIdから動的管理へ完全移行、アプリケーション正常起動確認
2.  **コンパイルエラーの修正**: ✅ **完了** - 全てのコンパイルエラーを解決（27個のエラーをすべて修正）
3.  **アプリケーション起動検証**: ✅ **完了** - `pnpm tauri dev`で正常起動確認済み
4.  **テストの実行と検証**: ✅ **完了** - 統合テストが失敗しないよう修正完了、全テスト通過確認済み
5.  **iroh-gossipの実装の完成**: iroh-gossipの基本的な実装は進行中ですが、実際のP2P通信の検証やエラーハンドリングの改善が必要です。
6.  **Tauri コマンドとストレージの統合**: ✅ **完了** - 動的ドキュメント参照に対応済み
7.  **ドキュメント同期とイベント処理**: ✅ **完了** - 統合テスト準備完了
8.  **統合テストの詳細検証**: ✅ **完了** - テストが失敗しないよう修正が完了し、全テスト通過確認済み
9.  **UIの改善**: 基本的なUIは実装されていますが、ユーザーエクスペリエンスの向上のために改善が必要です。特にネットワーク状態インジケーターの追加。
10. **パフォーマンスの最適化**: データ同期やP2P通信のパフォーマンスを最適化する必要があります。

## 最近の変更

1.  **🎉 動的NamespaceId管理システムの実装完了**:
    *   固定NamespaceIdアプローチから動的NamespaceId管理への完全移行を実現。
    *   `state.rs`でOnceLockを使用したグローバルドキュメント管理システムを実装。
    *   `create_or_load_documents()`関数: NamespaceID永続化と動的ドキュメント作成。
    *   `load_namespace_ids()`と`save_namespace_id()`関数: メタデータドキュメントによる永続化。
    *   グローバル関数の追加：`get_user_doc()`, `get_post_doc()`, `get_settings_doc()`。
2.  **🔧 コンパイルエラーの完全修正**:
    *   `iroh_docs::Doc`のインポートエラーを修正（正しくは`iroh_docs::rpc::client::docs::Doc`）。
    *   API互換性エラーの修正（`get_exact`から`Query::single_latest_per_key().key_exact()`への変更）。
    *   `content()`メソッドの不存在問題を解決（`blobs.read_to_bytes(entry.content_hash())`を使用）。
    *   型アノテーションエラーの修正（`DocType`型エイリアスの導入）。
    *   27個のコンパイルエラーをすべて解決し、警告のみに縮小。
3.  **✅ リポジトリファイルの動的アクセス対応**:
    *   全リポジトリファイル（user_repository.rs, post_repository.rs, settings_repository.rs）を固定NamespaceIdアクセスから動的ドキュメント参照に変更。
    *   `iroh.docs.open(*NAMESPACE_ID)`から`get_*_doc()`への変更完了。
4.  **🧪 テスト環境の対応**:
    *   `test_utils.rs`でテスト環境での動的ドキュメント初期化対応。
    *   `initialize_iroh_for_tests()`関数の実装で統合テスト実行環境を整備。
5.  **🚀 アプリケーション正常起動確認**:
    *   `pnpm tauri dev`で動的NamespaceId管理システムが正常に動作することを確認。
    *   Runtime Errorやクラッシュが発生しない状態を達成。
    *   すべてのTauriコマンドが新しい動的システムで正常に動作。
    *   Tauriイベントシステムを通じてフロントエンドに変更を通知。
    *   エラーハンドリングと再接続ロジックを含む。
    *   APIの互換性修正: `recv()` から `StreamExt::next()` への変更、`emit_all` から `emit` への変更。
6.  **フロントエンド統合**:
    *   `useDocumentEvents.ts` フックを作成してTauriイベントをリスナー。
    *   すべてのドキュメントイベントタイプのTypeScriptインターフェースを定義。
    *   `post-store.ts` の破損を修正し、`refreshPosts` と `setNetworkStatus` 機能を追加。
    *   `profile-store.ts` に `refreshUser` と `setNetworkStatus` 機能を追加。
    *   `App.tsx` に `useDocumentEvents` フックを統合。
7.  **ビルドシステムの更新**:
    *   `tracing` 依存関係を追加。
    *   RustバックエンドとTypeScriptフロントエンドの両方でコンパイルエラーなし。
4.  **ストレージレイヤーの再実装 (irohベース)**:
    *   `./src-tauri/src/storage` ディレクトリをゼロから再構築。
    *   `iroh` (Endpoint), `iroh-gossip`, `iroh-blobs`, `iroh-docs` を初期化し、Tauri アプリケーションのライフサイクルで管理する仕組み (`IrohNode`, `state`) を実装。
    *   リポジトリパターンを採用し、`UserRepository` (`user_repository.rs`) と `PostRepository` (`post_repository.rs`) を実装。
        *   `User` および `Post` モデルの CRUD (Create, Read, Update, Delete) 操作とリスト取得機能を提供。
        *   固定の `NamespaceId` を使用してドキュメントを分離。
        *   `iroh-docs` の `Doc` ハンドルを取得して操作する方式に変更。
    *   データモデル用のトレイト (`HasId`, `PostEntry`) を `storage/traits.rs` に移動。
    *   関連するビルドエラー（依存関係、API 非互換、型エラー、ライフタイムエラー等）を修正。
5.  **Tauri コマンドの更新**:
    *   `auth`, `post`, `profile` コマンドが新しいストレージリポジトリ関数を呼び出すように修正。
    *   `settings` コマンドが新しい `AppSettings` リポジトリを使用するように修正。
3.  **基本的なアプリケーション構造の実装**: (変更なし)
    *   フロントエンド: React、TypeScript、Zustandを使用したUI実装
    *   バックエンド: Tauriコマンドを使用したRust実装
    *   データモデル: Zodスキーマを使用したデータモデル定義
4.  **iroh-gossipの実装進行**: (変更なし)
    *   iroh-gossipの依存関係の追加
    *   MessageType列挙型の定義
    *   IrohNetwork構造体の実装
    *   トピックベースのメッセージング機能の実装
    *   publish_post, publish_profile, publish_follow, publish_unfollowなどの関数の実装
    *   基本的なテスト構造の実装
5.  **主要機能の実装**: (変更なし、ただしストレージ依存部分は更新済み)
    *   ユーザー認証: ユーザー作成、サインイン、ユーザーリスト取得
    *   投稿管理: 投稿作成、取得、検索 (検索は未実装)
    *   プロフィール管理: プロフィール取得、更新
    *   フォロー機能: フォロー、アンフォロー
6.  **データモデルの実装**: (変更なし、トレイトパス修正済み)
    *   User, Postなどの基本的なデータモデルを実装
    *   HasId, PostEntryなどのトレイトを定義
    *   シリアライズ/デシリアライズのサポート
7.  **AppSettings リポジトリの実装**:
    *   `src-tauri/src/models/settings.rs` に `Settings` 構造体を定義。
    *   `src-tauri/src/storage/repository/settings_repository.rs` を作成し、設定の保存・取得ロジックを実装。
    *   `src-tauri/src/storage/iroh_node.rs` に `SETTINGS_NAMESPACE_ID` を定義。
    *   グローバル設定とユーザー固有設定の両方をサポート。

## 次のステップ

### 短期的なタスク（1-2週間）

1.  **iroh-gossipの実装完成**: (最優先)
    *   実際のP2P通信のテストと検証
    *   エラーハンドリングの改善
    *   パフォーマンスの最適化
    *   実際のネットワーク環境でのテスト
2.  **UIの改善**: (優先度上昇)
    *   ネットワーク状態インジケーターの追加
    *   ユーザーエクスペリエンスの向上
    *   パフォーマンス最適化
3.  **テスト実装の拡充**:
    *   ストレージリポジトリに対するユニットテストを追加
    *   Tauri コマンドの統合テストを実装
    *   P2P通信のテスト方法の確立
4.  **Tauri コマンドのエラーハンドリング改善**:
    *   各コマンドハンドラでのエラーハンドリング (`map_err` など) を見直し、`StorageError` から各コマンド固有エラーへの変換を確実に行う。

### 中期的なタスク（3-5週間）

*   ユーザー認証とプロフィール管理の強化 (変更なし)
*   投稿作成と表示機能の強化 (変更なし)
*   タイムラインの最適化 (変更なし)
*   P2P通信の最適化 (変更なし)
*   フォロー/フォロワー機能の強化 (変更なし)
*   ローカル検索機能の実装 (`post_repository` に追加)

## アクティブな決定事項

1.  **技術スタックの選択**: (変更なし)
    *   フロントエンド: React、TypeScript、Vite、Zustand、TanStack Query
    *   バックエンド: Tauri、Rust、iroh-docs、iroh-gossip、iroh-blobs
    *   テスト: Vitest、Playwright、Mockall、tokio-test、test-log、env_logger
2.  **アーキテクチャの決定**: (変更なし)
    *   クライアントサイドアプリケーション
    *   分散型P2Pネットワーク
    *   ローカルファーストデータ管理
    *   モジュール型サービス統合
    *   トピックベースのメッセージング
3.  **データモデルの設計**: (変更なし)
    *   ユーザープロフィール（User）
    *   投稿（Post）
    *   フォロー関係
    *   メッセージタイプ（MessageType列挙型）
    *   ネットワークステータス（NetworkStatus）
4.  **実装アプローチ**: (変更なし)
    *   段階的な実装（MVP→拡張機能→エコシステム拡大→スケーリング）
    *   テスト駆動開発
    *   モジュール化されたコードベース
    *   エラーハンドリングの標準化（thiserrorを使用）
5.  **ストレージ技術**: (更新)
    *   `iroh-docs` を主要なデータストレージとして採用。
    *   `iroh-blobs` をコンテンツストレージとして採用。
    *   リポジトリパターンでデータアクセスを抽象化。
    *   固定の `NamespaceId` を使用して User, Post, Settings のドキュメントを分離 (現在の実装)。
    *   ユーザー固有の設定とグローバル設定の両方をサポート。

## 現在の考慮事項

1.  **パフォーマンス最適化**: (変更なし)
    *   iroh-docsのデータ構造の最適化
    *   P2P通信の効率化（特にトピックベースのメッセージング）
    *   リソース使用量の最適化（メモリ、CPU、ネットワーク帯域）
    *   大量のメッセージ処理時のパフォーマンス
2.  **セキュリティ考慮事項**: (変更なし)
    *   ユーザーデータの保護
    *   通信の暗号化（iroh-gossipの暗号化機能の活用）
    *   権限管理
    *   秘密鍵の安全な保存（現在はtempディレクトリに保存）
    *   メッセージの認証と検証
3.  **ユーザーエクスペリエンス**: (変更なし)
    *   オンボーディングプロセスの設計
    *   UIの使いやすさ
    *   オフライン対応
    *   エラーハンドリングの改善（ユーザーフレンドリーなエラーメッセージ）
    *   ネットワーク状態の表示
4.  **スケーラビリティ**: (変更なし)
    *   大規模データセットの処理
    *   多数のユーザーとの同期
    *   リソース使用量の管理
    *   効率的なデータ同期メカニズム
    *   トピック数の増加に対する対応
5.  **テスト戦略**: (優先度上昇)
    *   ユニットテスト（基本構造は実装済み）
    *   統合テスト
    *   E2Eテスト
    *   パフォーマンステスト
    *   モックの活用（mockallを使用）
    *   P2P通信のテスト方法
6.  **Namespace 管理**: (更新)
    *   現在使用している固定の Namespace ID (User, Post, Settings) は適切か？将来的にユーザーごと、または他の基準で Namespace を分割する必要はあるか？
    *   Namespace の Capability をどのように管理・共有するか？
    *   Settings Namespace はグローバル設定とユーザー固有設定の両方をサポートするように実装されている。
7.  **リポジトリの効率**: (更新)
    *   `list_user_posts` のようなフィルタリング処理は、データ量が増えると非効率になる。iroh-docs のクエリ機能やインデックス戦略を検討する必要があるか？
    *   大量のデータに対するクエリ最適化手法の検討。

## オープンな質問

1.  **iroh-docsのパフォーマンス**: (変更なし) 大規模データセットでのiroh-docsのパフォーマンスはどうか？特に多数のエントリーを持つドキュメントの同期パフォーマンスはどうか？
2.  **iroh-gossipのスケーラビリティ**: (変更なし) 多数のユーザーがいる場合のiroh-gossipのスケーラビリティはどうか？トピックベースのメッセージングの効率はどうか？実装したトピック設計は効率的か？
3.  **クロスプラットフォーム互換性**: (変更なし) 異なるプラットフォーム間での一貫したユーザーエクスペリエンスをどのように確保するか？特にTauriアプリケーションのプラットフォーム固有の挙動をどう扱うか？
4.  **オフライン対応**: (変更なし) オフライン状態でのユーザーエクスペリエンスをどのように最適化するか？特に同期の競合解決をどのように実装するか？
5.  **モデレーション**: (変更なし) 分散型システムでのコンテンツモデレーションをどのように実装するか？ユーザー主導のモデレーションメカニズムは可能か？
6.  **テスト戦略**: (変更なし) 分散型システムのテストをどのように効果的に実装するか？特にP2P通信のテストをどのように行うか？モックを使用したテストは十分か？
7.  **秘密鍵管理**: (変更なし) 現在の秘密鍵保存方法（tempディレクトリ）は本番環境に適しているか？より安全な保存方法は？
8.  **エラーハンドリング**: (変更なし) 現在のエラーハンドリング（thiserrorを使用）は十分か？ユーザーフレンドリーなエラーメッセージをどのように提供するか？
9.  **トピック設計**: (変更なし) 現在のトピック設計（global/posts, user/{id}/posts, user/{id}/profile, user/{id}/following）は効率的か？より良い設計はあるか？
10. **Namespace 管理戦略**: (更新) User, Post, Settings で固定 Namespace を使用する現在の方法は適切か？将来的な拡張性を考慮すると、どのような管理戦略が望ましいか？
11. **イベント処理アーキテクチャ**: (新規) `subscribe` を使用した変更監視とイベント発火のベストプラクティスは？イベントループのパフォーマンスと信頼性をどう確保するか？