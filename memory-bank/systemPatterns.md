# システムパターン

## アーキテクチャ概要

本アプリケーションは、以下の主要なアーキテクチャパターンに基づいて設計されています：

1. **クライアントサイドアプリケーション**: Tauriを使用したデスクトップアプリケーションとして実装
2. **分散型P2Pネットワーク**: 中央サーバーに依存しない分散型アーキテクチャ
3. **ローカルファーストデータ管理**: データはまずローカルに保存され、P2P通信で同期
4. **モジュール型サービス統合**: 検索やサジェストなどのサービスをモジュール化

## 高レベルアーキテクチャ

```
+------------------------+      +------------------------+
|     ユーザーノード1     |      |     ユーザーノード2     |
|                        |      |                        |
|  +------------------+  |      |  +------------------+  |
|  |   Tauriアプリ     |  |      |  |   Tauriアプリ     |  |
|  +------------------+  |      |  +------------------+  |
|          |             |      |          |             |
|  +------------------+  |      |  +------------------+  |
|  |   iroh-docs DB    |  |<---->|  |   iroh-docs DB    |  |
|  +------------------+  |      |  +------------------+  |
|          |             |      |          |             |
|  +------------------+  |      |  +------------------+  |
|  |   iroh-gossip    |  |<---->|  |   iroh-gossip    |  |
|  +------------------+  |      |  +------------------+  |
|          |             |      |          |             |
|  +------------------+  |      |  +------------------+  |
|  |   iroh-blobs     |  |<---->|  |   iroh-blobs     |  |
|  +------------------+  |      |  +------------------+  |
+------------------------+      +------------------------+
           /|\                             /|\
            |                               |
            |                               |
            |                               |
            v                               v
  +------------------------+      +------------------------+
  |  Cloudflare Workers   |      |   サービスプロバイダー   |
  |  (DHT遅延軽減リレー)  |      | (検索、サジェストなど)  |
  +------------------------+      +------------------------+
```

## 主要コンポーネントの関係

```
App.tsx --> Router
Router --> Pages
Pages --> Components
Components --> Hooks
Hooks --> Services
Services --> Tauri Commands
Tauri Commands --> Rust Backend
Rust Backend --> iroh-docs Storage
Rust Backend --> iroh-gossip Network
Rust Backend --> iroh-blobs Content
Hooks --> Zustand Stores
```

## 設計パターン

### 1. フロントエンド

1. **コンポーネントベース設計**: Reactコンポーネントを使用したモジュール化されたUI
2. **カスタムフック**: 再利用可能なロジックをカスタムフックとして抽出
3. **状態管理**: Zustandを使用した軽量で効率的な状態管理
4. **データフェッチング**: TanStack Queryを使用した効率的なデータフェッチングと状態管理
5. **型安全**: TypeScriptとZodを使用した厳格な型チェックとバリデーション

### 2. バックエンド（Rust）

1. **コマンドパターン**: Tauriコマンドを使用したフロントエンドとバックエンドの通信
2. **リポジトリパターン**: データアクセスを抽象化するストレージレイヤー
3. **イベント駆動型アーキテクチャ**: iroh-gossipを使用したイベントベースの通信
4. **分散型データストレージ**: iroh-docsを使用した効率的なデータ同期
5. **コンテンツアドレス可能ストレージ**: iroh-blobsを使用したバイナリデータの管理
6. **モジュール化**: 機能ごとにモジュール化されたRustコード

## データフロー

### 1. ユーザー認証フロー

1. ユーザーがプロフィールを作成
2. 公開鍵/秘密鍵ペアが生成され、秘密鍵はローカルに安全に保存
3. ユーザープロフィールがiroh-docsに保存
4. プロフィール情報がiroh-gossipを通じて発信（公開情報のみ）

### 2. 投稿作成フロー

1. ユーザーが投稿を作成
2. 投稿がローカルのiroh-docsに保存
3. 添付ファイルがある場合はiroh-blobsに保存
4. 投稿がiroh-gossipを通じて発信
5. 他のユーザーが投稿を受信し、自分のiroh-docsに保存

### 3. データ同期フロー

1. ユーザーがオンラインになると、iroh-gossipを通じて接続
2. 最新の変更をリクエスト
3. 変更がiroh-docsの同期プロトコルによって自動的にマージ
4. 必要なバイナリデータがiroh-blobsを通じて取得

### 4. 設定保存/取得フロー

1. ユーザーが設定画面で設定を変更（またはアプリが設定を読み込む）
2. フロントエンドが `update_settings` または `get_settings` Tauri コマンドを呼び出す
3. Tauri コマンドハンドラが `settings_repository` の関数を呼び出す
4. `settings_repository` が `iroh-docs` の `settings` Namespace にアクセスし、設定データを保存または取得する
5. 結果がフロントエンドに返される

## 技術的決定

### 1. Tauriの選択理由

- クロスプラットフォーム対応
- 軽量で高パフォーマンス
- Webテクノロジーとネイティブ機能の組み合わせ
- セキュリティ重視の設計

### 2. iroh-docsの選択理由

- 効率的な同期プロトコル
- マルチディメンショナルなキーバリュードキュメント
- オフライン対応
- 複数デバイス間の同期サポート
- iroh-gossipとiroh-blobsとの統合

### 3. iroh-gossipの選択理由

- 効率的なP2P通信
- トピックベースのメッセージング
- スケーラブルな設計
- 低レイテンシー

### 4. iroh-blobsの選択理由

- コンテンツアドレス可能なストレージ
- 効率的なデータ転送
- 重複排除
- iroh-docsとの統合

### 5. Zustandの選択理由

- 軽量で高パフォーマンス
- シンプルなAPI
- Reactとの統合が容易
- デバッグが容易

## セキュリティ考慮事項

1. **ユーザー認証**: 公開鍵暗号を使用した安全な認証
2. **データ保護**: ローカルデータの安全な保存
3. **通信セキュリティ**: 暗号化されたP2P通信
4. **権限管理**: 適切なアクセス制御と権限管理

## スケーラビリティ考慮事項

1. **データ分割**: 大規模データセットのための効率的な分割戦略
2. **効率的なP2P通信**: ネットワーク帯域の最適化
3. **リソース使用量**: メモリとCPU使用量の最適化
4. **増分同期**: 効率的なデータ同期メカニズム